#!/bin/bash

LOCATION="us-east4-a"
CLUSTER=qitransientcluster
REG_SERVER=gcr.io/${RESOURCES}

function GetPlatformContainer()
{
    # Use the Prebuilt gcloud sdk container provided by Google.
    docker pull google/cloud-sdk
}

GetPlatformContainer

# Login with the container. This currently requires user interaction
# at the browser to complete. The below command creates a volume
# at the ${CONFIG_MOUNT} location in order to persist kubernetes
# login credentials by setting the KUBECONFIG environment variable.
#
function Login()
{
    docker run \
        -it \
        --name ${CONTAINER_NAME} \
        -e KUBECONFIG=${CONFIG_MOUNT}/kube_config \
        --mount type=volume,target=${CONFIG_MOUNT} \
        google/cloud-sdk \
        gcloud auth login
}

Login

# Common docker command component for gcloud and kubectl commands inside
# of the google/cloud-sdk container.
#
PREFIX="docker run \
    --rm \
    -e KUBECONFIG=${CONFIG_MOUNT}/kube_config \
    --volumes-from ${CONTAINER_NAME} \
    google/cloud-sdk"

GCLOUD="$PREFIX gcloud"
KUBECTL="$PREFIX kubectl"

function Provision()
{
    # Create a hosting project for transient resources.
    $GCLOUD projects create $RESOURCES

    $GCLOUD config set project $RESOURCES
    $GCLOUD config set compute/zone $LOCATION

    # GCP requires setting up billing on a project before certain services
    # can be used. GCP does not automatically create a link to billing
    # as the billing structure of GCP allows for many billing accounts within
    # an organization.
    echo
    echo CHOOSE A BILLING ACCOUNT TO LINK WITH "\"${RESOURCES}\""

    # Create a menu for billing account options.
    let option_id=0
    accounts=()
    while IFS= read -r line; do
        let option_id++

        # Provide an options menu to select a billing account.
        echo "[${option_id}] ${line}"
        account_id="${line%% *}"
        accounts+=("$account_id")

    # Lists all of the available billing accounts for the current user
    # formatted to list the account number and the display name.
    #
    done < <(docker run \
        --rm \
        -e KUBECONFIG=${CONFIG_MOUNT}/kube_config \
        --volumes-from ${CONTAINER_NAME} \
        google/cloud-sdk \
        gcloud beta billing accounts list \
        --format "table[no-heading](name,displayName)")

    echo
    read -n 1 -p "> " CHOICE
    echo

    let CHOICE--

    $GCLOUD alpha billing projects link $RESOURCES --billing-account ${accounts[CHOICE]}

    # Enable the use of the container and the container registry APIs for project
    $GCLOUD services enable containerregistry.googleapis.com
    $GCLOUD services enable container.googleapis.com
}

Provision

function PrepareDocker()
{
    # Add authentication information for docker to login to gcr.io
    $GCLOUD auth configure-docker --project $RESOURCES

    # Login to gcr.io
    $GCLOUD auth print-access-token | docker login \
        -u oauth2accesstoken \
        --password-stdin https://gcr.io
}

PrepareDocker

REMOTE_IMAGE=$(PushToRemote ${APPLICATION} ${REG_SERVER})

function Deploy()
{
    # Create a cluster to run the container
    $GCLOUD container clusters create $CLUSTER \
        --num-nodes 1 \
        --enable-basic-auth \
        --no-enable-ip-alias \
        --metadata disable-legacy-endpoints=true \
        --network "default" \
        --issue-client-certificate \
        --scopes \
            compute-rw,storage-ro

    $GCLOUD container clusters get-credentials $CLUSTER --zone ${LOCATION}

    K8S_ENDPOINT=$($GCLOUD container clusters describe $CLUSTER \
        --format="table[no-heading](endpoint)")

    DEPLOYMENT=${APPLICATION}-deployment
    APPSERVICE=${APPLICATION}-service

    $KUBECTL run \
        $DEPLOYMENT \
        --image=${REMOTE_IMAGE} \
        --server=${K8S_SERVER} \
        --port 8888

    $KUBECTL expose deployment \
        ${DEPLOYMENT} \
        --name ${APPSERVICE} \
        --type=LoadBalancer \
        --server=${K8S_SERVER} \
        --port 8888 \
        --target-port 8888

    # Get the IP Address of the exposed Jupyter notebook service running
    # in the kubernetes cluster using an exponential backoff technique
    let backoff=2
    let attempts=0
    while [ -z "$JUPYTER_SERVER" ]; do
        JUPYTER_SERVER=$($KUBECTL \
            get services $APPSERVICE \
            -o=custom-columns=EXTERNAL-IP:.status.loadBalancer.ingress..ip \
            --no-headers)

        # Querying for the external IP immediately after setting up a service
        # in Kubernetes will sometimes result in the external IP not being set
        # and the query will return "<none>". When this happens, we should
        # backoff and try again.
        #
        if [[ "<none>" = "$JUPYTER_SERVER" ||  ! $? = 0 ]]; then
            let attempts+=1
            JUPYTER_SERVER=

            echo "Failed to connect to GKE to retrieve server IP."
            echo "Retrying in: $backoff seconds."
            sleep $backoff

            let backoff*=2
            if [ $backoff -ge 128 ]; then
                echo "Failed to retrieve server IP after $attempts attempts." >&2
                echo "Stopping further execution" >&2
                exit 1
            fi
        else
            echo "Jupyter Server running at $JUPYTER_SERVER"
        fi
    done
}

Deploy

function ConnectToServer()
{
    JUPYTER_POD=$($KUBECTL \
        get pods \
        -o=custom-columns=NAME:.metadata.name \
        --no-headers)

    $KUBECTL logs -f $JUPYTER_POD
}

# Given a source directory, copies its contents to a GCP bucket
#
# ARGUMENTS:
#   _SOURCE_DIR  - The local machine source to copy
#   _BUCKET_NAME - The GCP Data Bucket to upload data
#   _AUTH_CONFIG - The pre-authenticated config container
#
function CopyData()
{
    _SOURCE_DIR=$1
    _BUCKET_NAME=$2
    _AUTH_CONFIG=$3

    docker run \
        --rm \
        --mount type=bind,source="${_SOURCE_DIR}",target=/mnt/data \
        --volumes-from ${_AUTH_CONFIG} \
        google/cloud-sdk \
        gsutil -m \
            cp -r /mnt/data/* gs://${_BUCKET_NAME}
}
